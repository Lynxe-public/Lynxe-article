# AI Agent系列 - 2 ReAct Agent 与传统的写流程对比，有哪些本质不同？

## 关于这个系列

作为 Lynxe(原JManus）的作者，我花费了很多课余时间来完善这个Func-Agent框架，也因此对于什么是ReAct Based Agent 有了更深一些的理解。

所以想把这些内容总结出来，是因为这个项目本身核心目的就是探索Agent的前沿最佳实践，目前已经有所小成，Lynxe能解决我自己面对的80%以上的问题了，所以我觉得值得把我实验下来有效的东西写出来，方便大家快速入门。

你可以访问 [Lynxe(菱科斯)](https://github.com/spring-ai-alibaba/Lynxe) 阅读详细源码来学习agent的一些最佳实践。这是一个非常完善的产品级的 Func-Agent框架。

## 系列计划

* [什么是 ReAct Agent？](./react-agent-intro.md)
* [Agent 与传统的写流程对比，有哪些本质不同？](./react-agent-vs-traditional.md)
* 工具toolcall/mcp管理的最佳实践
* 上下文管理的一些实践
* 并行执行的最佳实践与我走过的弯路
* 其余 想到或得到反馈在写 

## 正文开始

在上一篇文章中，我们介绍了什么是 ReAct Agent。现在我们来聊聊一个更实际的问题：Agent 和传统的编程方式、工作流方式到底有什么本质不同？为什么我们需要 Agent？

## 三种方式的对比

先看一个直观的对比表：

| 维度 | 传统编程 | Workflow 工作流 | Agent |
|------|---------|---------------|-------|
| **开发所需技能** | 需掌握编程语言、算法、系统设计等专业知识 | 理解编程原理，理解图形化拖拽产品的能力，以及扩展函数的写法 | 自然语言即可完成所有业务逻辑 |
| **完成任务的方式** | 完全依赖硬编码规则，难以处理不确定或复杂场景 | 固定路径流转，条件判断有限，无法动态调整策略 | 在自然语言的引导下，动态调整策略完成任务 |
| **修改与维护成本** | 多角色瀑布协作：运营发现问题 -> 产品拆解排期 -> 研发 -> 部署 -> 测试 -> 上线 | 基本只能节省部署环节：运营发现问题 -> 产品拆解排期 -> 研发 -> 测试 -> 上线 | 业务自闭环：(发现->测试->解决） |

这个表格可能看起来有点抽象，让我用更具体的方式来解释这三种方式的本质区别。

## 传统编程：一切都要提前想好

传统编程就像建房子，你得先把所有图纸都画好，所有材料都准备好，然后严格按照图纸施工。一旦遇到图纸上没有的情况，就得重新设计。

### 实际例子

假设你要做一个"根据天气推荐穿衣"的功能：

**传统编程方式：**
```python
def get_weather_recommendation(city):
    # 1. 查询天气
    weather = query_weather_api(city)
    temperature = weather['temperature']
    condition = weather['condition']
    
    # 2. 根据温度判断
    if temperature < 10:
        return "建议穿厚外套"
    elif temperature < 20:
        return "建议穿薄外套"
    elif temperature < 25:
        return "建议穿长袖"
    else:
        return "建议穿短袖"
    
    # 3. 如果API返回错误怎么办？需要写异常处理
    # 4. 如果数据格式不对怎么办？需要写数据验证
    # 5. 如果用户想要更详细的建议怎么办？需要修改代码
```

这种方式的问题很明显：
- **硬编码规则**：所有逻辑都是提前写死的，遇到新情况就得改代码
- **异常处理复杂**：各种边界情况都要提前考虑，代码会变得很复杂
- **修改成本高**：改一个小逻辑，需要开发、测试、部署，整个流程走一遍

## Workflow 工作流：流程固定，但更灵活一些

Workflow 工作流就像搭积木，你可以用图形化的方式把不同的"积木"（节点）连接起来，形成固定的流程。比传统编程灵活一些，但本质上还是固定的路径。

### 实际例子

同样的"根据天气推荐穿衣"功能，用 Workflow 的方式：

```
[开始] -> [查询天气API] -> [判断温度] -> [返回建议] -> [结束]
         ↓ (如果失败)
      [错误处理节点]
```

这种方式比传统编程好一些：
- **可视化**：不需要写代码，拖拽就能完成
- **模块化**：每个节点是独立的，可以复用
- **但问题依然存在**：
  - 流程是固定的，如果用户想要"先查天气，再查穿衣建议，最后保存到文件"，就需要重新设计整个流程
  - 条件判断有限，复杂的逻辑还是需要写代码
  - 复杂流程维护难度也会变大
  - 修改流程仍然需要开发人员参与

## Agent：边走边看，动态调整

Agent 就像一个有经验的向导，你告诉他目标，他会根据实际情况动态调整路线。不需要提前把所有情况都想好，遇到问题就解决，走不通就换条路。

### 实际例子

同样的"根据天气推荐穿衣"功能，用 Agent 的方式：

你只需要告诉 Agent："帮我查一下北京今天天气怎么样，适合穿什么衣服，然后保存到文件。"

Agent 会自己决定：
1. 先调用天气查询工具
2. 根据天气结果，决定调用穿衣建议工具
3. 获取建议后，决定调用文件写入工具
4. 如果某个工具失败了，会自动尝试其他方法

整个过程是动态的，不需要提前设计好所有步骤。

## 本质区别：谁在做决策？

这三种方式最本质的区别在于：**谁在做决策？**

- **传统编程**：程序员在做决策，把所有可能的情况都提前想好，写成代码
- **Workflow**：产品/开发在做决策，设计固定的流程路径
- **Agent**：AI 在做决策，根据实际情况动态调整策略

## 开发技能要求：从专业到自然语言

### 传统编程
需要掌握：
- 编程语言（Python、Java、JavaScript 等）
- 算法和数据结构
- 系统设计
- 调试和测试
- 版本控制

门槛很高，需要专业培训。

### Workflow 工作流
需要掌握：
- 理解编程的基本原理（变量、条件判断、循环等）
- 会用图形化工具拖拽节点
- 会写一些扩展函数（如果需要）

门槛中等，需要一定的技术理解能力。

### Agent
需要掌握：
- **自然语言**：会用中文或英文描述需求即可

门槛极低，任何人都可以使用。

## 修改和维护成本：从瀑布到闭环

### 传统编程的协作流程

```
运营发现问题 
  -> 产品拆解需求、排期 
    -> 研发写代码 
      -> 测试验证 
        -> 部署上线 
          -> 运营验证
```

整个过程可能需要几天甚至几周，涉及多个角色，沟通成本高。

### Workflow 的协作流程

```
运营发现问题 
  -> 产品拆解需求、排期 
    -> 研发调整流程 
      -> 测试验证 
        -> 上线（部署环节可能自动化）
```

比传统编程好一些，但依然需要多个角色协作。

### Agent 的协作流程

```
运营发现问题 
  -> 运营直接用自然语言描述需求给 Agent 
    -> Agent 自动完成 
      -> 运营测试验证 
        -> 如果不对，继续用自然语言调整
```

**运营自闭环**，不需要产品、研发、测试、部署等环节，发现问题到解决问题可能只需要几分钟。

## 实际场景对比

让我们用一个更复杂的场景来对比：**"帮我分析一下最近一周的销售数据，找出异常订单，生成报告并发送给团队"**

### 传统编程方式

需要：
1. 写代码连接数据库
2. 写 SQL 查询销售数据
3. 写算法分析异常（定义什么是异常）
4. 写代码生成报告
5. 写代码发送邮件
6. 处理各种异常情况（数据库连接失败、邮件发送失败等）
7. 测试、部署

可能需要：1-2 周开发时间，涉及后端开发、数据分析、运维等多个角色。

### Workflow 方式

需要：
1. 设计流程：查询数据 -> 分析数据 -> 生成报告 -> 发送邮件
2. 配置各个节点
3. 写一些扩展函数处理复杂逻辑
4. 测试、上线

可能需要：3-5 天，需要技术人员参与。

### Agent 方式

只需要：
1. 告诉 Agent："帮我分析一下最近一周的销售数据，找出异常订单，生成报告并发送给团队"
2. Agent 自动完成所有步骤
3. 如果结果不对，继续用自然语言调整："异常订单的定义改一下，订单金额超过平均值的 3 倍才算异常"

可能需要：**几分钟到几小时**，运营人员自己就能完成。

## 什么时候用哪种方式？

虽然 Agent 看起来很强大，但并不是所有场景都适合用 Agent。三种方式各有适用场景：

### 传统编程适合：
- 性能要求极高的场景（高频交易、实时游戏等）
- 需要精确控制的场景（安全系统、金融系统等）
- 逻辑非常固定、不会变化的场景

### Workflow 适合：
- 业务流程相对固定，但需要可视化管理的场景
- 需要非技术人员参与流程设计的场景
- 需要流程审计和版本管理的场景

### Agent 适合：
- 需求经常变化的场景
- 需要处理不确定性的场景
- 需要快速迭代和试错的场景
- 非技术人员需要自主完成任务的场景

## 总结

Agent 和传统编程、Workflow 的本质区别在于：

1. **决策者不同**：Agent 是 AI 在做决策，而不是人提前设计好所有逻辑
2. **灵活性不同**：Agent 可以根据实际情况动态调整，而不是走固定路径
3. **门槛不同**：Agent 只需要自然语言，大大降低了使用门槛
4. **迭代速度不同**：Agent 可以实现运营自闭环，从发现问题到解决问题只需要几分钟

当然，Agent 也不是万能的。它适合处理复杂、不确定的任务，但对于需要精确控制、高性能的场景，传统编程仍然是更好的选择。

关键是要理解每种方式的本质，根据实际场景选择最合适的方式。在很多场景下，Agent 可以大大提升效率，让非技术人员也能完成复杂的任务，这就是 Agent 的核心价值。
